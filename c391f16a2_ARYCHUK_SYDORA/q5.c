#include <stdio.h>
#include <stdlib.h>
#include "sqlite3.h"
#include <time.h>

/*
Q5 15pts

The goal of this question is to quantify the impact (if any) of the built-in 
R-Tree module in SQLite. To do so, build standard SQlite indexes on each of 
the individual Cartesian coordinates of the POIs.

Write a C program, in a file called q5.c that:

    1. Generates 100 randomly chosen bounding squares with side of 
    length l, read as a parameter to the program. The coordinates 
    of the square should be generated by your program.

    2. Computes the average time (out of 20 runs for each query rectangle) 
    to find the total number of objects in that square, using the R-Tree
    and using the standard SQLite indexes (only).

    3. Prints the average times for each scenario after all runs.

The output of the program should look like this:

Parameter l: ...

Average runtime with r-tree: ... ms

Average runtime without r-tree: ... ms

*/

int main(int argc, char **argv)
{
	  sqlite3 *db; //the database
	  sqlite3_stmt *stmtr, *stmti; //the select statement

    srand(time(NULL));

  	int rci, rcr;

  	if( argc!=3 )
    {
    	  fprintf(stderr, "Usage: %s <database file> <side length>\n", argv[0]);
    	  return(1);
  	}

  	rci = sqlite3_open(argv[1], &db);
  	if( rci )
    {
      	fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
      	sqlite3_close(db);
      	return(1);
  	}

    int length = atoi(argv[2]);

    double lstRandY[100];

    double lstRandX[100];

    int i, j = 0;

    for(i = 0 ; i < 100 ; i++) 
    {
        lstRandX[i] = (rand() % (1000 - length));
    }

    for(i = 0 ; i < 100 ; i++) 
    {        
        lstRandY[i] = (rand() % (1000 - length));
    }

    clock_t timeArrayFinIndex[20][100];

    clock_t timeArrayFinRTree[20][100];

    // Selects all poi from poi_comp_index 
    char *sql_index = "SELECT * " \
                          "FROM poi indexed BY poi_comp_index " \
                          "WHERE lat >= ? and lon >= ? " \
                          "and lat <= ? and lon <= ?;";

    // Selects all poi from poi_index from R-Tree
    char *sql_r_tree = "SELECT * " \
                          "FROM poi_index " \
                          "WHERE minLat >= ? and minLon >= ? " \
                          "and maxLat <= ? and maxLon <= ?;";


    rci = sqlite3_prepare_v2(db, sql_index, -1, &stmti, 0);
    rcr = sqlite3_prepare_v2(db, sql_r_tree, -1, &stmtr, 0);

    if (rci != SQLITE_OK) 
      {  
          fprintf(stderr, "Preparation failed: %s\n", sqlite3_errmsg(db));
          sqlite3_close(db);
          return 1;
      }   

    if (rcr != SQLITE_OK) 
      {  
          fprintf(stderr, "Preparation failed: %s\n", sqlite3_errmsg(db));
          sqlite3_close(db);
          return 1;
      }   


    for (i = 0; i < 20; ++i) 
    {

      for (j = 0; j < 100; ++j) 
      {
        clock_t start = clock();
        clock_t diff = 0;
        int msec = 0;

        sqlite3_bind_double(stmti, 1, lstRandX[i]);
        sqlite3_bind_double(stmti, 2, lstRandY[i]);
        sqlite3_bind_double(stmti, 3, lstRandX[i] + length);
        sqlite3_bind_double(stmti, 4, lstRandY[i] + length);      

        while((rci = sqlite3_step(stmti)) == SQLITE_ROW) { }

        diff = (clock() - start);
    	msec = ((diff * 1000) / CLOCKS_PER_SEC);

        timeArrayFinIndex[i][j] = msec;

        sqlite3_reset(stmti);

        start = clock();
        diff = 0;

        sqlite3_bind_double(stmtr, 1, lstRandX[i]);
        sqlite3_bind_double(stmtr, 2, lstRandY[i]);
        sqlite3_bind_double(stmtr, 3, lstRandX[i] + length);
        sqlite3_bind_double(stmtr, 4, lstRandY[i] + length);      

        while((rcr = sqlite3_step(stmtr)) == SQLITE_ROW) { }

        diff = (clock() - start);
    	msec = ((diff * 1000) / CLOCKS_PER_SEC);

        timeArrayFinRTree[i][j] = msec;

        msec = 0;

        sqlite3_reset(stmtr);
      }
    } 

    //output
    double outer_count_i = 0;
    double outer_count_r = 0;
    for (i = 0; i < 100; ++i)
    {
      double inner_count_i = 0;
      double inner_count_r = 0;
      for (j = 0; j < 20; ++j) 
      {
        inner_count_r += timeArrayFinRTree[j][i];

        inner_count_i += timeArrayFinIndex[j][i];
      }
      outer_count_i += (inner_count_i / 20);
      outer_count_r += (inner_count_r / 20);
    }

    double rtime = (outer_count_r / 100);
    double itime = (outer_count_i / 100);

    sqlite3_finalize(stmtr);
    sqlite3_finalize(stmti);

    sqlite3_close(db);

    printf("Parameter l: %d\n", length);

    printf("Average runtime with r-tree: %f\n", rtime);

    printf("Average runtime without r-tree: %f\n", itime);

    return 0;
}
